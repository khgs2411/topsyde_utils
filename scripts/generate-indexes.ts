import { readdir, stat, readFile, writeFile } from "fs/promises";
import { join, relative, dirname, basename } from "path";
import { existsSync, mkdirSync } from "fs";
import { execSync } from "child_process";

const SRC_DIR = join(process.cwd(), "src");
const MAIN_INDEX_FILE = join(SRC_DIR, "index.ts");
const PACKAGE_JSON_PATH = join(process.cwd(), "package.json");

// Helper to check if directory should be included
const shouldIncludeDir = (dir: string): boolean => {
  const excluded = [".git", "node_modules", "dist", "__tests__"];
  return !excluded.includes(dir) && !dir.startsWith(".");
};

// Helper to check if file should be included
const shouldIncludeFile = (file: string): boolean => {
  return file.endsWith(".ts") && !file.endsWith(".test.ts") && file !== "index.ts";
};

// Discover all directories recursively
async function discoverDirectories(basePath: string): Promise<string[]> {
  const results: string[] = [];

  async function scan(dir: string) {
    const entries = await readdir(dir);

    for (const entry of entries) {
      const fullPath = join(dir, entry);
      const stats = await stat(fullPath);

      if (stats.isDirectory() && shouldIncludeDir(entry)) {
        const relativePath = relative(basePath, fullPath);
        results.push(relativePath);
        await scan(fullPath);
      }
    }
  }

  await scan(basePath);
  return results.sort();
}

// Get all TypeScript files in a directory
async function getFilesInDirectory(dirPath: string): Promise<string[]> {
  const fullPath = join(SRC_DIR, dirPath);
  const files = await readdir(fullPath);
  return files.filter(shouldIncludeFile);
}

// Extract default export class name from file content
function extractDefaultExportName(content: string, filename: string): string | null {
  // Check for class name in default export
  const classMatch = content.match(/(?:abstract\s+)?class\s+(\w+)(?:\s+extends\s+(?:Error|.*?))?\s*{/);
  if (classMatch && content.includes("export default")) {
    return classMatch[1];
  }
  
  // If no class match but has default export, use capitalized filename
  if (content.includes("export default")) {
    return filename
      .replace(/\.ts$/, "")
      .replace(/\.([a-z])/g, (match, p1) => p1.toUpperCase())
      .replace(/^\w/, (c) => c.toUpperCase());
  }
  
  return null;
}

// Extract named exports from file content
function extractNamedExports(content: string): string[] {
  const exports: string[] = [];
  
  // Match standard named exports (const, enum, type, interface)
  const standardRegex = /export\s+(const|enum|type|interface)\s+([A-Z][A-Za-z0-9_]*)/g;
  let match;
  
  while ((match = standardRegex.exec(content)) !== null) {
    exports.push(match[2]);
  }
  
  // Match export statements with multiple exports
  const multiExportRegex = /export\s+{([^}]*)}/g;
  while ((match = multiExportRegex.exec(content)) !== null) {
    const exportList = match[1];
    // Split by commas and process each export
    const items = exportList.split(',').map(item => item.trim());
    
    for (const item of items) {
      // Handle "as" aliases: "OriginalName as ExportName"
      if (item.includes(' as ')) {
        const [_, exportName] = item.split(' as ').map(part => part.trim());
        if (exportName && exportName.match(/^[A-Z][A-Za-z0-9_]*$/)) {
          exports.push(exportName);
        }
      } 
      // Handle direct exports
      else if (item.match(/^[A-Z][A-Za-z0-9_]*$/)) {
        exports.push(item);
      }
    }
  }
  
  // Remove duplicates
  return [...new Set(exports)];
}

// Generate index file for a specific directory
async function generateDirectoryIndex(dirPath: string): Promise<void> {
  const fullPath = join(SRC_DIR, dirPath);
  const files = await getFilesInDirectory(dirPath);
  
  if (files.length === 0) return;
  
  let content = "// This file is auto-generated by scripts/generate-indexes.ts\n";
  content += "// Do not edit this file directly\n\n";
  
  // Export all named exports from each file
  for (const file of files) {
    const filename = file.replace(/\.ts$/, "");
    content += `export * from './${filename}';\n`;
  }
  
  // Export default exports with proper names
  for (const file of files) {
    const filePath = join(fullPath, file);
    const fileContent = await readFile(filePath, "utf8");
    const defaultExportName = extractDefaultExportName(fileContent, file);
    
    if (defaultExportName) {
      const filename = file.replace(/\.ts$/, "");
      content += `export { default as ${defaultExportName} } from './${filename}';\n`;
    }
  }
  
  // Create the index file
  const indexPath = join(fullPath, "index.ts");
  await writeFile(indexPath, content);
}

// Generate the main index file
async function generateMainIndex(directories: string[]): Promise<void> {
  let content = "// This file is auto-generated by scripts/generate-indexes.ts\n";
  content += "// Do not edit this file directly\n\n";
  
  // Export all modules
  content += "// Export all modules\n";
  
  // First collect all files in the root directory
  const rootFiles = await getFilesInDirectory("");
  for (const file of rootFiles) {
    const filename = file.replace(/\.ts$/, "");
    content += `export * from './${filename}';\n`;
  }
  
  // Export all modules from subdirectories
  // This ensures types from nested modules are available at the root level
  for (const dir of directories) {
    const files = await getFilesInDirectory(dir);
    
    for (const file of files) {
      const filename = file.replace(/\.ts$/, "");
      content += `export * from './${dir}/${filename}';\n`;
    }
  }
  
  content += "\n// Export default classes\n";
  
  // Export default classes from root directory
  for (const file of rootFiles) {
    const filePath = join(SRC_DIR, file);
    const fileContent = await readFile(filePath, "utf8");
    const defaultExportName = extractDefaultExportName(fileContent, file);
    
    if (defaultExportName) {
      const filename = file.replace(/\.ts$/, "");
      content += `export { default as ${defaultExportName} } from './${filename}';\n`;
    }
  }
  
  // Export default classes from subdirectories
  for (const dir of directories) {
    const files = await getFilesInDirectory(dir);
    
    for (const file of files) {
      const filePath = join(SRC_DIR, dir, file);
      const fileContent = await readFile(filePath, "utf8");
      const defaultExportName = extractDefaultExportName(fileContent, file);
      
      if (defaultExportName) {
        const filename = file.replace(/\.ts$/, "");
        content += `export { default as ${defaultExportName} } from './${dir}/${filename}';\n`;
      }
    }
  }
  
  content += "\n// Re-export specific items for backward compatibility\n";
  
  // Re-export constants and enums from root directory
  for (const file of rootFiles) {
    const filePath = join(SRC_DIR, file);
    const fileContent = await readFile(filePath, "utf8");
    const namedExports = extractNamedExports(fileContent);
    
    if (namedExports.length > 0) {
      const filename = file.replace(/\.ts$/, "");
      content += `export { ${namedExports.join(",")} } from './${filename}';\n`;
    }
  }
  
  // Re-export constants and enums from subdirectories
  for (const dir of directories) {
    const files = await getFilesInDirectory(dir);
    
    for (const file of files) {
      const filePath = join(SRC_DIR, dir, file);
      const fileContent = await readFile(filePath, "utf8");
      const namedExports = extractNamedExports(fileContent);
      
      if (namedExports.length > 0) {
        const filename = file.replace(/\.ts$/, "");
        content += `export { ${namedExports.join(",")} } from './${dir}/${filename}';\n`;
      }
    }
  }
  
  await writeFile(MAIN_INDEX_FILE, content);
}

// Update package.json exports configuration
async function updatePackageExports(directories: string[]): Promise<void> {
  try {
    // Read the current package.json
    const packageJsonContent = await readFile(PACKAGE_JSON_PATH, 'utf8');
    const packageJson = JSON.parse(packageJsonContent);
    
    // Initialize exports object
    packageJson.exports = {
      '.': {
        types: './dist/index.d.ts',
        default: './dist/index.js'
      }
    };
    
    // Initialize typesVersions object
    packageJson.typesVersions = { '*': {} };
    
    // Find leaf directories (those that don't have subdirectories)
    const leafDirs = new Set<string>(directories);
    
    // Remove directories that are parents of other directories
    for (const dir of directories) {
      const parts = dir.split('/');
      if (parts.length > 1) {
        // Check if any parent directory is in the set
        let parentPath = '';
        for (let i = 0; i < parts.length - 1; i++) {
          if (parentPath) parentPath += '/';
          parentPath += parts[i];
          leafDirs.delete(parentPath);
        }
      }
    }
    
    // Add each leaf directory to exports and typesVersions
    for (const dir of Array.from(leafDirs).sort()) {
      const exportPath = `./${dir}`;
      
      // Add to exports
      packageJson.exports[exportPath] = {
        types: `./dist/${dir}/index.d.ts`,
        default: `./dist/${dir}/index.js`
      };
      
      // Add to typesVersions
      packageJson.typesVersions['*'][dir] = [`./dist/${dir}/index.d.ts`];
    }
    
    // Write the updated package.json
    await writeFile(
      PACKAGE_JSON_PATH,
      JSON.stringify(packageJson, null, 2) + '\n'
    );
    
    console.log('Updated package.json exports configuration');
  } catch (error) {
    console.error('Error updating package.json:', error);
  }
}

// Main function
async function main() {
  try {
    // Discover all directories
    const directories = await discoverDirectories(SRC_DIR);
    
    // Generate index files for each directory
    for (const dir of directories) {
      await generateDirectoryIndex(dir);
      console.log(`Generated index for ${dir}`);
    }
    
    // Generate the main index file
    await generateMainIndex(directories);
    console.log(`Generated main index file`);
    
    // Update package.json exports
    await updatePackageExports(directories);
    
    console.log("Index files generated successfully!");
  } catch (error) {
    console.error("Error generating index files:", error);
    process.exit(1);
  }
}

// Run the main function
main(); 