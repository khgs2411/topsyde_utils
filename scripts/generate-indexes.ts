import { readdir, stat, readFile, writeFile } from "fs/promises";
import { join, relative, dirname, basename } from "path";
import { existsSync, mkdirSync } from "fs";
import { execSync } from "child_process";

const SRC_DIR = join(process.cwd(), "src");
const MAIN_INDEX_FILE = join(SRC_DIR, "index.ts");

// Helper to check if directory should be included
const shouldIncludeDir = (dir: string): boolean => {
  const excluded = [".git", "node_modules", "dist", "__tests__"];
  return !excluded.includes(dir) && !dir.startsWith(".");
};

// Helper to check if file should be included
const shouldIncludeFile = (file: string): boolean => {
  return file.endsWith(".ts") && !file.endsWith(".test.ts") && file !== "index.ts";
};

// Discover all directories recursively
async function discoverDirectories(basePath: string): Promise<string[]> {
  const results: string[] = [];

  async function scan(dir: string) {
    const entries = await readdir(dir);

    for (const entry of entries) {
      const fullPath = join(dir, entry);
      const stats = await stat(fullPath);

      if (stats.isDirectory() && shouldIncludeDir(entry)) {
        const relativePath = relative(basePath, fullPath);
        results.push(relativePath);
        await scan(fullPath);
      }
    }
  }

  await scan(basePath);
  return results.sort();
}

// Get all TypeScript files in a directory
async function getFilesInDirectory(dirPath: string): Promise<string[]> {
  const fullPath = join(SRC_DIR, dirPath);
  const files = await readdir(fullPath);
  return files.filter(shouldIncludeFile);
}

// Extract default export class name from file content
function extractDefaultExportName(content: string, filename: string): string | null {
  // Check for class name in default export
  const classMatch = content.match(/(?:abstract\s+)?class\s+(\w+)(?:\s+extends\s+(?:Error|.*?))?\s*{/);
  if (classMatch && content.includes("export default")) {
    return classMatch[1];
  }
  
  // If no class match but has default export, use capitalized filename
  if (content.includes("export default")) {
    return filename
      .replace(/\.ts$/, "")
      .replace(/\.([a-z])/g, (match, p1) => p1.toUpperCase())
      .replace(/^\w/, (c) => c.toUpperCase());
  }
  
  return null;
}

// Extract named exports from file content
function extractNamedExports(content: string): string[] {
  const exports: string[] = [];
  
  // Match standard named exports (const, enum, type, interface)
  const standardRegex = /export\s+(const|enum|type|interface)\s+([A-Z][A-Za-z0-9_]*)/g;
  let match;
  
  while ((match = standardRegex.exec(content)) !== null) {
    exports.push(match[2]);
  }
  
  // Match export statements with multiple exports
  const multiExportRegex = /export\s+{([^}]*)}/g;
  while ((match = multiExportRegex.exec(content)) !== null) {
    const exportList = match[1];
    // Split by commas and process each export
    const items = exportList.split(',').map(item => item.trim());
    
    for (const item of items) {
      // Handle "as" aliases: "OriginalName as ExportName"
      if (item.includes(' as ')) {
        const [_, exportName] = item.split(' as ').map(part => part.trim());
        if (exportName && exportName.match(/^[A-Z][A-Za-z0-9_]*$/)) {
          exports.push(exportName);
        }
      } 
      // Handle direct exports
      else if (item.match(/^[A-Z][A-Za-z0-9_]*$/)) {
        exports.push(item);
      }
    }
  }
  
  // Remove duplicates
  return [...new Set(exports)];
}

// Generate index file for a specific directory
async function generateDirectoryIndex(dirPath: string): Promise<void> {
  const fullPath = join(SRC_DIR, dirPath);
  const files = await getFilesInDirectory(dirPath);
  
  if (files.length === 0) return;
  
  let content = "// This file is auto-generated by scripts/generate-indexes.ts\n";
  content += "// Do not edit this file directly\n\n";
  
  // Export all named exports from each file
  for (const file of files) {
    const filename = file.replace(/\.ts$/, "");
    content += `export * from './${filename}';\n`;
  }
  
  // Export default exports with proper names
  for (const file of files) {
    const filePath = join(fullPath, file);
    const fileContent = await readFile(filePath, "utf8");
    const defaultExportName = extractDefaultExportName(fileContent, file);
    
    if (defaultExportName) {
      const filename = file.replace(/\.ts$/, "");
      content += `export { default as ${defaultExportName} } from './${filename}';\n`;
    }
  }
  
  // Create the index file
  const indexPath = join(fullPath, "index.ts");
  await writeFile(indexPath, content);
}

// Generate the main index file
async function generateMainIndex(directories: string[]): Promise<void> {
  let content = "// This file is auto-generated by scripts/generate-indexes.ts\n";
  content += "// Do not edit this file directly\n\n";
  
  // Export all modules
  content += "// Export all modules\n";
  
  // First collect all files in the root directory
  const rootFiles = await getFilesInDirectory("");
  for (const file of rootFiles) {
    const filename = file.replace(/\.ts$/, "");
    content += `export * from './${filename}';\n`;
  }
  
  // Export all modules from subdirectories
  // This ensures types from nested modules are available at the root level
  for (const dir of directories) {
    const files = await getFilesInDirectory(dir);
    
    for (const file of files) {
      const filename = file.replace(/\.ts$/, "");
      content += `export * from './${dir}/${filename}';\n`;
    }
  }
  
  content += "\n// Export default classes\n";
  
  // Export default classes from root directory
  for (const file of rootFiles) {
    const filePath = join(SRC_DIR, file);
    const fileContent = await readFile(filePath, "utf8");
    const defaultExportName = extractDefaultExportName(fileContent, file);
    
    if (defaultExportName) {
      const filename = file.replace(/\.ts$/, "");
      content += `export { default as ${defaultExportName} } from './${filename}';\n`;
    }
  }
  
  // Export default classes from subdirectories
  for (const dir of directories) {
    const files = await getFilesInDirectory(dir);
    
    for (const file of files) {
      const filePath = join(SRC_DIR, dir, file);
      const fileContent = await readFile(filePath, "utf8");
      const defaultExportName = extractDefaultExportName(fileContent, file);
      
      if (defaultExportName) {
        const filename = file.replace(/\.ts$/, "");
        content += `export { default as ${defaultExportName} } from './${dir}/${filename}';\n`;
      }
    }
  }
  
  content += "\n// Re-export specific items for backward compatibility\n";
  
  // Re-export constants and enums from root directory
  for (const file of rootFiles) {
    const filePath = join(SRC_DIR, file);
    const fileContent = await readFile(filePath, "utf8");
    const namedExports = extractNamedExports(fileContent);
    
    if (namedExports.length > 0) {
      const filename = file.replace(/\.ts$/, "");
      content += `export { ${namedExports.join(",")} } from './${filename}';\n`;
    }
  }
  
  // Re-export constants and enums from subdirectories
  for (const dir of directories) {
    const files = await getFilesInDirectory(dir);
    
    for (const file of files) {
      const filePath = join(SRC_DIR, dir, file);
      const fileContent = await readFile(filePath, "utf8");
      const namedExports = extractNamedExports(fileContent);
      
      if (namedExports.length > 0) {
        const filename = file.replace(/\.ts$/, "");
        content += `export { ${namedExports.join(",")} } from './${dir}/${filename}';\n`;
      }
    }
  }
  
  await writeFile(MAIN_INDEX_FILE, content);
}

// Update package.json with exports
async function updatePackageJson(directories: string[]): Promise<void> {
  // Get all top-level directories
  const topLevelDirs = [...new Set(directories.map(dir => dir.split("/")[0]))];
  
  // Create exports object
  const exports: Record<string, any> = {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    }
  };
  
  // Add exports for each directory
  for (const dir of directories) {
    exports[`./${dir}`] = {
      "types": `./dist/${dir}/index.d.ts`,
      "default": `./dist/${dir}/index.js`
    };
  }
  
  // Create typesVersions object
  const typesVersions: Record<string, any> = {
    "*": {}
  };
  
  // Add types for each directory
  for (const dir of directories) {
    typesVersions["*"][dir] = [`./dist/${dir}/index.d.ts`];
  }
  
  // Read package.json
  const packageJsonPath = join(process.cwd(), "package.json");
  const packageJson = JSON.parse(await readFile(packageJsonPath, "utf8"));
  
  // Update package.json
  packageJson.exports = exports;
  packageJson.typesVersions = typesVersions;
  
  // Write updated package.json
  await writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
}

// Create parent directory index files that export from child directories
async function createParentDirectoryIndexes(directories: string[]): Promise<void> {
  // Create a map of parent directories to child directories
  const parentToChildren: Record<string, string[]> = {};
  
  for (const dir of directories) {
    const parent = dirname(dir);
    if (parent !== ".") {
      if (!parentToChildren[parent]) {
        parentToChildren[parent] = [];
      }
      parentToChildren[parent].push(basename(dir));
    }
  }
  
  // For each parent directory, create an index file that exports from child directories
  for (const [parent, children] of Object.entries(parentToChildren)) {
    const parentPath = join(SRC_DIR, parent);
    const indexPath = join(parentPath, "index.ts");
    
    // Skip if the parent directory already has an index file
    if (existsSync(indexPath)) {
      let content = await readFile(indexPath, "utf8");
      
      // Add exports for each child directory if they don't already exist
      for (const child of children) {
        const exportStatement = `export * from './${child}';`;
        if (!content.includes(exportStatement)) {
          content += `\n${exportStatement}`;
        }
      }
      
      await writeFile(indexPath, content);
    } else {
      // Create a new index file
      let content = "// This file is auto-generated by scripts/generate-indexes.ts\n";
      content += "// Do not edit this file directly\n\n";
      
      // Export from each child directory
      for (const child of children) {
        content += `export * from './${child}';\n`;
      }
      
      await writeFile(indexPath, content);
    }
  }
}

// Main function
async function main() {
  try {
    // Discover all directories
    const directories = await discoverDirectories(SRC_DIR);
    
    // Generate index files for each directory
    for (const dir of directories) {
      await generateDirectoryIndex(dir);
    }
    
    // Generate index file for root directory
    await generateDirectoryIndex("");
    
    // Create parent directory indexes
    await createParentDirectoryIndexes(directories);
    
    // Generate main index file
    await generateMainIndex(directories);
    
    // Update package.json
    await updatePackageJson(directories);
    
    console.log("Index files generated successfully!");
  } catch (error) {
    console.error("Error generating index files:", error);
    process.exit(1);
  }
}

// Run the main function
main(); 